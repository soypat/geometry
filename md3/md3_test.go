// DO NOT EDIT.
// This file was generated automatically
// from gen.go. Please do not edit this file.

package md3

import (
	"fmt"
	"math"
	"math/rand"
	"testing"

	"github.com/soypat/geometry/internal"
)

func TestRotation(t *testing.T) {
	const tol = 1e-7
	v := Vec{X: 1}
	y90 := RotationMat4(math.Pi/2, Vec{Y: 1})
	got := y90.MulPosition(v)
	want := Vec{Z: -1}
	if !EqualElem(got, want, tol) {
		t.Errorf("want %v, got %v", want, got)
	}
}

func TestRotationConversions(t *testing.T) {
	const tol = internal.Smallfloat64 / 10
	rotations := []Quat{
		Rotation(1, Vec{X: 1}),
		Rotation(1, Vec{X: 1, Y: 1}),
		Rotation(2, Vec{X: 1, Y: 1, Z: 1}),
		Rotation(math.Pi, Vec{X: 1}),
		Rotation(math.Pi, Vec{X: 1, Y: 1}),
		Rotation(math.Pi, Vec{X: 1, Y: 1, Z: 1}),
		Rotation(2*math.Pi, Vec{X: 1}),
		Rotation(0, Vec{X: 1}),
	}
	rng := newRNG(1)
	for _, rot := range rotations {
		angle, axis := rot.Rotation()
		gotrot := Rotation(angle, axis)
		if !EqualQuat(rot, gotrot, tol) {
			t.Errorf("want %v, got %v", rot, gotrot)
		}
		if !rot.EqualOrientation(gotrot, tol) {
			t.Errorf("not equal orientations %v, got %v", rot, gotrot)
		}
		m3 := rot.RotationMat3()
		for i := 0; i < 20; i++ {
			v := rng.Vec()
			vgot := MulMatVec(m3, v)
			vwant := rot.Rotate(v)
			if !EqualElem(vgot, vwant, tol) {
				t.Errorf("want %v, got %v", vwant, vgot)
			}
		}
	}
}

func TestRotationBetweenVecs(t *testing.T) {
	const tol = internal.Smallfloat64 / 10
	rng := newRNG(1)
	for i := 0; i < 80; i++ {
		start := rng.Vec()
		dest := rng.Vec()
		rot := RotationBetweenVecs(start, dest)
		gotDest := rot.Rotate(start)
		if !EqualElem(Unit(gotDest), Unit(dest), tol) { // test direction, so use Unit.
			t.Errorf("want %v, got %v", dest, gotDest)
		}
	}
}

func TestSVD(t *testing.T) {
	const tol = 1e-6
	a := mat3(-0.558253, -0.0461681, -0.505735, -0.411397, 0.0365854, 0.199707, 0.285389, -0.313789, 0.200189)
	// Using approximate sqrt:
	// Accurate sqrt values:
	uwant := mat3(-0.849310, -0.354882, -0.390809, -0.278376, 0.930100, -0.239626, 0.448530, -0.094725, -0.888734)
	swant := mat3(0.860883, -0.000000, 0.000000, 0.000000, 0.413613, -0.000000, -0.000000, 0.000000, -0.296320)
	vwant := mat3(0.832469, -0.511493, -0.213002, -0.129771, 0.193746, -0.972431, 0.538660, 0.837160, 0.094911)
	u, s, v := a.SVD()

	if !EqualMat3(u, uwant, tol) {
		t.Error("U mismatch")
		fmt.Println("U got:")
		printMat(u)
		fmt.Println("U want:")
		printMat(uwant)
	}
	if !EqualMat3(s, swant, tol) {
		t.Error("S mismatch")
		fmt.Println("S got:")
		printMat(s)
		fmt.Println("S want:")
		printMat(swant)
	}
	if !EqualMat3(v, vwant, tol) {
		t.Error("V mismatch")
		fmt.Println("V got:")
		printMat(v)
		fmt.Println("V want:")
		printMat(vwant)
	}
}

func printMat(a Mat3) {
	fmt.Printf("%f %f %f \n", a.x00, a.x01, a.x02)
	fmt.Printf("%f %f %f \n", a.x10, a.x11, a.x12)
	fmt.Printf("%f %f %f \n", a.x20, a.x21, a.x22)
}

func newRNG(src int) *rngGen {
	return &rngGen{rng: *rand.New(rand.NewSource(int64(src)))}
}

type rngGen struct {
	rng rand.Rand
}

func (rng *rngGen) Vec() Vec {
	return Vec{X: rng.Float(), Y: rng.Float(), Z: rng.Float()}
}

func (rng *rngGen) Float() float64 {
	return float64(rng.rng.Float64())
}

func (rng *rngGen) FloatRange(start, end float64) float64 {
	return float64(rng.rng.Float64())*(end-start) + start
}

func (rng *rngGen) VecRange(start, end float64) Vec {
	return Vec{X: rng.FloatRange(start, end), Y: rng.FloatRange(start, end), Z: rng.FloatRange(start, end)}
}
