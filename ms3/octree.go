package ms3

import (
	"github.com/soypat/geometry/i3"
)

// Octree implements heapless 3D spatial Octree algorithms.
type Octree struct {
	// Resolution is the size of the smallest cube in the Octree. [i3.Cube].Lvl==0.
	Resolution float32
	// Origin represents the position of the first cube's first corner (most negative/smallest corner).
	Origin Vec
}

// DecomposeDFS decomposes icubes from the end of cubes into their octree sub-icubes
// and appends them to the cubes buffer, resulting in a depth-first traversal (DFS) of the octree.
// This way cubes will contain the largest cubes at the start (low index) and the smallest cubes at the end (high index).
// Cubes that reach the smallest size will be consumed and their 3D corners appended to dst. Smallest size cubes do not decompose into more icubes.
// cubes with level of zero are discarded and no action is taken.
//
// The icube decomposition continues until one or more of the following conditions are met:
//   - Smallest cube size is reached and the capacity in 3D dst can't store a resolution sized icube corners, calculated as cap(dst)-len(dst) < 64.
//   - Need to decompose a icube to more icubes but capacity of cubes buffer not enough to store an octree decomposition, calculated as cap(cubes)-len(cubes) < 8.
//   - cubes buffer has been fully consumed and is empty, calculated as len(cubes) == 0.
//
// This algorithm is HEAPLESS: this means dst and cubes buffer capacities are not modified.
func (oct Octree) DecomposeDFS(dst []Vec, cubes []i3.Cube) ([]Vec, []i3.Cube) {
	for len(cubes) > 0 {
		lastIdx := len(cubes) - 1
		cube := cubes[lastIdx]
		if cube.Lvl == 0 {
			// Cube has been moved to prune queue. Discard and keep going.
			cubes = cubes[:lastIdx]
			continue
		}
		if cube.IsSecondSmallest() {
			// Is base-level cube.
			if cap(dst)-len(dst) < 8*8 {
				break // No space for position buffering.
			}
			subcubes := cube.Octree()
			for _, scube := range subcubes {
				corners := oct.CubeCorners(scube, oct.Resolution)
				// corners := scube.(origin, res)
				dst = append(dst, corners[:]...)
			}
			cubes = cubes[:lastIdx] // Trim cube used.

		} else {
			// Is cube with sub-cubes.
			if cap(cubes)-len(cubes) < 8 {
				break // No more space for cube buffering.
			}
			subcubes := cube.Octree()
			// We trim off the last cube which we just processed in append.
			cubes = append(cubes[:lastIdx], subcubes[:]...)
		}
	}
	return dst, cubes
}

// DecomposeBFS decomposes start into octree cubes and appends them to dst without surpassing dst's slice capacity
// and continues to decompose the resulting cubes until all cubes are minimumDecomposedLvl or dst capacity reached.
// Smallest cubes will remain at the highest index of dst. The boolean value returned indicates whether the
// argument start icube was able to be decomposed and its children added to dst.
func (oct Octree) DecomposeBFS(dst []i3.Cube, start i3.Cube, minimumDecomposedLvl int) ([]i3.Cube, bool) {
	if minimumDecomposedLvl < 1 {
		panic("bad minimumDecomposedLvl")
	}
	if cap(dst) < 8 {
		return dst, false // No space to decompose new cubes.
	} else if start.Lvl <= minimumDecomposedLvl {
		return dst, false // Cube already fully decomposed.
	}

	subCubes := start.Octree()
	startIdx := len(dst)
	firstIdx := len(dst)
	dst = append(dst, subCubes[:]...) // Cubes will be of at minimum minLvl-1
	for cap(dst)-len(dst) >= 8 {
		// Decompose and append cubes.
		cube := dst[firstIdx]
		if cube.Lvl <= minimumDecomposedLvl {
			// Reached cube of minimum prunable level.
			break
		}
		subCubes := cube.Octree()
		// Is cube with sub-cubes.
		// We trim off the last cube which we just processed in append.
		dst = append(dst, subCubes[:]...)
		firstIdx++
	}
	// Move cubes to start of buffer from where we started consuming them.
	n := copy(dst[startIdx:], dst[firstIdx:])
	dst = dst[:startIdx+n]
	return dst, true
}

// SafeMove appends cubes from the end of src to dst while taking care
// not to leave dst without space to decompose to smallest cube level using DFS.
// Cubes appended to dst from src are removed from src.
func (oct Octree) SafeMove(dst, src []i3.Cube) (newDst, newSrc []i3.Cube) {
	if len(src) == 0 {
		return dst, src
	}
	// Calculate amount of cubes that would be generated in DFS
	srcGenCubes := 8 * (src[0].Lvl + 1) // TODO(soypat): Checking the first cube is very (read as "too") conservative.
	neededSpace := 1 + srcGenCubes      // plus one for appended cube.
	// Calculate free space in dst after cubes generated by 1 decomposition+append.
	free := cap(dst) - neededSpace
	trimIdx := max(0, len(src)-free)
	prevCap := cap(dst)
	dst = append(dst, src[trimIdx:]...)
	if cap(dst) != prevCap {
		panic("heapless assumption broken")
	}
	src = src[:trimIdx]
	return dst, src
}

// SafeSpread takes cube swith Lvl>0 from end of src  and "spreads" them over dstWithLvl0 cube buffer taking special care so that the buffer can still be decomposed to smallest cubes.
// The buffer dstWithLvl0 is considered to have exactly numLvl0 cubes with Lvl==0 anywhere within. These Lvl==0 cubes will be replaced
// with src cubes first.
func (oct Octree) SafeSpread(dstWithLvl0, src []i3.Cube, numLvl0 int) (newDst, newSrc []i3.Cube, newNumLvl0 int) {
	if len(src) == 0 || numLvl0 == 0 || len(dstWithLvl0) == 0 {
		return dstWithLvl0, src, numLvl0 // No work to do.
	}
	srcIdx := len(src) - 1 // Start appending from end of src.
	cube := src[srcIdx]
	neededSpace := 8*cube.Lvl + 1
	for i := 0; numLvl0 > 0 && i < len(dstWithLvl0); i++ {
		free := cap(dstWithLvl0) - i
		if free < neededSpace {
			break // If we add this cube we'd overflow the target buffer upon DFS decomposition, so don't.
		}
		// Look for zero level cubes (invalid/empty/discarded).
		if dstWithLvl0[i].Lvl != 0 {
			continue
		} else if cube.Lvl == 0 {
			panic("bad src cube in octreeSafeSpread")
		}
		// Calculate free space.
		dstWithLvl0[i] = cube
		numLvl0--
		srcIdx--
		if srcIdx < 0 {
			break // Done processing cubes.
		}
		cube = src[srcIdx]
		neededSpace = 8*cube.Lvl + 1
	}
	return dstWithLvl0, src[:srcIdx+1], numLvl0
}

// CubeCorners returns the corners of the cube starting with the z=0 xy plane corners.
// cubeSize should be the result of [Octree.CubeSize] called on c. It is left to the user to do for performance reasons.
func (oct Octree) CubeCorners(c i3.Cube, cubeSize float32) [8]Vec {
	origin := oct.CubeOrigin(c, cubeSize)
	return [8]Vec{
		Add(origin, Vec{X: 0, Y: 0, Z: 0}),
		Add(origin, Vec{X: cubeSize, Y: 0, Z: 0}),
		Add(origin, Vec{X: cubeSize, Y: cubeSize, Z: 0}),
		Add(origin, Vec{X: 0, Y: cubeSize, Z: 0}),
		Add(origin, Vec{X: 0, Y: 0, Z: cubeSize}),
		Add(origin, Vec{X: cubeSize, Y: 0, Z: cubeSize}),
		Add(origin, Vec{X: cubeSize, Y: cubeSize, Z: cubeSize}),
		Add(origin, Vec{X: 0, Y: cubeSize, Z: cubeSize}),
	}
}

// CubeOrigin returns the Cube argument origin (lowest index corner position) in the octree.
// cubeSize should be the result of [Octree.CubeSize] called on c. It is left to the user to do for performance reasons.
func (oct Octree) CubeOrigin(c i3.Cube, cubeSize float32) Vec {
	idx := c.Index()
	return Add(oct.Origin, Scale(cubeSize, Vec{X: float32(idx.X), Y: float32(idx.Y), Z: float32(idx.Z)}))
}

// CubeSize returns the length of the sides of the cube.
func (oct Octree) CubeSize(c i3.Cube) float32 {
	dim := 1 << (c.Lvl - 1)
	return float32(dim) * oct.Resolution
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
